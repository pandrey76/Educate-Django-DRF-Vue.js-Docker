<template>
  <!-- Тэг div добавляем, потому, что должен быть единственный узел (это div) в руте. -->
  <div>
    <table>
      <thead>
        <tr>
          <th>Vendor</th>
          <th>Model</th>
          <th>Year</th>
          <th>Volume</th>
        </tr>
      </thead>
      <tbody>

      <!-- Выводим список машин полученных с backend -->
      <!-- У нас отрисовались данные и как мы видим мы не где с DOM не взаимодействуем. Всё
           отрисовалось как-только cars обновился. -->
      <tr v-for="car in cars"
          v-bind:key="car">
         <td>{{car.vendor}}</td>
         <td>{{car.model}}</td>
         <td>{{car.year}}</td>
         <td>{{car.volume}}</td>
      </tr>
      </tbody>
    </table>
      <input placeholder="vendor" v-model="currentCar.vendor"/>
      <input placeholder="model" v-model="currentCar.model"/>
      <!--
        Два последующих параметра у нас числа. Так записываем для того, чтобы Vue автоматически
        ту строку, которую мы ввели конвертировал в число.
      -->
      <input placeholder="year" v-model.number="currentCar.year"/>
      <input placeholder="volume" v-model.number="currentCar.volume"/>
    <!-- Ивенты во Vue начинаются на v-on -->
    <button v-on:click="createCar()">Create</button>
    <!-- Можно использовать и упрощённую запись -->
<!--     <button @click="createCar()">Create</button>-->
  </div>
</template>

<script>
/* У Vue.js есть два типа данных, к которым можно получить доступ:
    Первый - это date, собственные аттрибуты компонента это те аттрибуты, которые может менять
сам компонент;
    Второй - это Proxy (Properties), данные которые передаются сверху, т.е. например если мы
    передаём <td> с ключём НELLO и присвоеенным значением WORLD, то у него может быть Пропс с этим
    именем HELLO и он его может использовать (<td> :HELLO="'WORLD'">{{ car.vendor }}<td>),
    он может его рендерить, может считать с ним что-то,
    но он его не может менять(позже объснят почему).
*/

/* data() - это функция, для расшаривания состояния между объектами, она создаёт на каждый
   экземпляр отдельный объект.
   */

export default {

  name: 'home',

  data() {
    return {
      cars: [],
      // input изменился мне надо где-то хранить его сначения
      // Это у нас объект в который у нас будет складыватся что-то
      // Мы привязываем inputы, чтобы при изменении inputов автоматически в объект
      // добавлялись свойства. Это делается во Vue с помощью v-model.
      currentCar: {}
    };
  },
  // Для удобной работы с Vue.js можно установить расширение в chrome "Vue.js devtools".
  //  У Vue.js есть жизненые циклы и хуки для них, жизненый цикл начинается с того, что компонент
  // создаётся функция "created()", потом она примонтируется к DOM, это функция(метод) "mount()",
  // потом есть хук "beforedestroy()" и т.д. можно посмотреть в документации на Vue.js.
  // Вызываем асинхронно
  async created() {
    await this.fetchCars();
  },
  methods: {
    async fetchCars()
    {
      // Как только эта штука создалась мы хотим сделать запрос. Обычно запрос делается функцией
      // "axios", но мы будем пользоваться функцией fetch(), которая умеет делать тоже самое, а ещё
      // она встроена в большенство браузеров.
      // Мы хотим сделать запрос на наш backend (http://127.0.0.1:8000/api/carsl).

      // Это асинхронный GET запрос, ничего менять не надо.
      const response = await fetch('http://127.0.0.1:8000/api/cars/');
      // Мы дожидаемся, что "fetch" нам что, то вернул, и мы получаем наш масив "cars", несмотря на
      // то, что "cars" у нас завёрнута в "data", она начинает доступно быть в контексте компонента.
      // Декодирование в json почему то тоже асинхронное.
      this.cars = await response.json();
    },
    async createCar()
    {
      //Здесь мы отправляем PUT запрос
       const response = await fetch('http://127.0.0.1:8000/api/cars/', {
        method: 'POST',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
          },
         // Метод JSON.stringify() преобразует значение JavaScript в строку JSON, возможно с
         // заменой значений, если указана функция замены, или с включением только
         // определённых свойств, если указан массив замены.
         body: JSON.stringify(this.currentCar),
         // Как мы заметили ранее при создании объкта через REST API нам пришёл статусный
         // код 201 Created, а не 200 Ok. Это говорит о том, что Django REST framework
         // придерживается правильных HTTP кодов возврата. И на основе этого мы можем понять
         // создалось у нас что нибудь или нет. поэтому мы будем делать следующую проверку.
        });
         if(response.status !== 201)
         {
           // В продакшене alert применять очень плохо, т.к. это останавливает намертво
           // весь java script код. Надо создать отдельный асинхронный popup.
           alert(JSON.stringify(await response.json(), null, 2));
           // Мы здесь используем такую запись (JSON.stringify(await response.json()), т.к. мы
           // сначала разворачиваем из JSON, а потом заворачиваем в JSON.
         }
         //И если статус равен 201, то делаем следующее:
          await this.fetchCars();
    }
  }
};
</script>
